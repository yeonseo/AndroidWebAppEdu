// C++ 원전 제 3 권 예제 설치 프로그램
// 1권 설치 프로그램을 조금 수정한 것임
// arj 압축으로 데이터를 보관하고 압축을 풀어 주기만 한다.
// 1994.11.28

#include <graphics.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <dir.h>
#include <dos.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
#include "shhan.h"

void readpcx16p(char *,int,int);       /* 16 색 pcx를 읽는 함수 */
void readline16p(FILE *,int,int,int);
void readpalette16(char *);
void hom(int,int,int,int,int,int,int);
void dan(int,int,int,int,int,int,int,int);
void bar2(int l,int t,int r,int b);
#define he0 *h1
#define he1 *h1+h2


char buf[128];
ffblk ffb;
int result;
char cwd[80];       // 최초 작업을 시작한 디렉토리
char cwd2[80];      // arj.exe의 경로를 보관할 문자 배열
int disk;           // 최초 작업을 시작한 드라이버
char command[128];  // 명령 문자열
int chapter;        // 장별로 압축을 풀 것인가를 기억한다.
char drive[3],path[66],name[9],ext[5];
int gd=0,gm;
int h1,h2;

void main()
{
char ch;
getcwd(cwd,80);      // 작업을 시작한 경로를 보관한다.
disk=getdisk();
registerbgidriver(EGAVGA_driver);
registerbgidriver(Herc_driver);
initgraph(&gd,&gm,"");
if (gd==7) {h1=0;h2=1;} else {h1=1;h2=0;}
shset(gd,1);
setfillstyle(1,7);
bar2(0,0,getmaxx(),getmaxy());

hom(15,5,625,195,8,15,1);
readpcx16p("won.pcx",20,10);      // 그림 읽어 들임
dan(85,200,555,255,15,8,1,1);     // 설치 안내문 출력
dan(90,205,550,250,8,15,1,1);
setfillstyle(1,11he0);
bar2(91,206,549,249);
shhan(100,210,"C++을 내것으로 레퍼런스편의 예제 파일을 하드",0,11,0,0);
shhan(100,226,"디스크에 설치합니다. 아래 질문에 응답해 주십시요.",0,11,0,0);

dan(85,260,555,380,15,8,1,1);    // 메시지 대화창
dan(90,265,550,375,8,15,1,1);
do {
ch=0;
setfillstyle(1,1he0);
bar2(91,266,549,374);
shhan(100,270,"설치할 디렉토리를 입력하십시요.",15,1,0,0);
shmode(1);
strcpy(buf,"c:\\cpp3ex");
shget(100,290,buf,15,1,80,1);
result=findfirst(buf,&ffb,FA_DIREC);        // 디렉토리가 있는지 본다.
if (result) {
  shhan(100,270,"디렉토리가 없습니다. 만들까요?",15,1,0,0);
  shhan(100,290,"M:만듦  R:재입력  C:설치 취소",15,1,0,0);
  ch=getch();
  ch=tolower(ch);
  if (ch=='m')
    {
    if (mkdir(buf))
      {
      setfillstyle(1,1);
      bar(91,266,549,374);
      shhan(100,270,"디렉토리 이름이 잘못 입력되었습니다.",15,1,0,0);
      shhan(100,290,"다시 입력해 주십시요.",15,1,0,0);
      delay(1500);
      ch='r';
      continue;
      }
    setfillstyle(1,1he0);
    bar(91,266,549,374);
    shhan(100,270,"디렉토리를 만들었습니다.",15,1,0,0);
    shhan(100,290,"이 디렉토리에 예제 파일을 설치합니다.",15,1,0,0);
    delay(1000);
    }
  if (ch=='c')
    {
    closegraph();
    exit(0);
    }
  }
}while (ch=='r');


fnsplit(buf,drive,path,name,ext);
setdisk(tolower(drive[0])-'a');     // 설치할 디렉토리로 이동
chdir(buf);
setfillstyle(1,1he0);
bar(91,266,549,374);
/*   3권은 무조건 x옵션으로 압축을 푼다.
shhan(100,270,"장별로 디렉토리를 구성할까요?",15,1,0,0);
shhan(100,290,"아니면 현재 디렉토리에 모두 설치할까요",15,1,0,0);
shhan(100,310,"C:장별로   A:모두",15,1,0,0);
ch=getch();
  if (ch=='c') chapter=1;
    else chapter=0;
*/
chapter=1;
setfillstyle(1,1he1);
bar(95,195,545,255);
setfillstyle(1,15he0);
bar(100,200,540,250);
shhan(120,220,"설치를 시작합니다. 약 1분이 소요됩니다.",0,15,0,0);
delay(2000);
closegraph();
clrscr();
if (cwd[2]=='\\' && cwd[3]==0)   // 루트 디렉토리 처리
  {
  if (disk==0) strcpy(cwd2,"a:");
  if (disk==1) strcpy(cwd2,"b:");
  }
else strcpy(cwd2,cwd);
if (chapter==1)
sprintf(command,"%s%s%s%s",cwd2,"\\arj x -y ",cwd2,"\\cpp3ex");
 else sprintf(command,"%s%s%s%s",cwd2,"\\arj e -y ",cwd2,"\\cpp3ex");
result=system(command);
delay(500);
setdisk(disk);    // 최초 작업 디렉토리로 복귀한다.
chdir(cwd);

initgraph(&gd,&gm,"");
setfillstyle(1,7);
bar2(0,0,getmaxx(),getmaxy());
dan(85,260,555,380,15,8,1,1);
dan(90,265,550,375,8,15,1,1);
setfillstyle(1,1he0);
bar2(91,266,549,374);
if (result==-1) {
  switch (errno) {
    case ENOMEM:shhan(100,300,"메모리가 부족합니다.",15,1,0,0);
	 break;
    case ENOENT:shhan(100,300,"파일이 없습니다.",15,1,0,0);
	 break;
    case E2BIG:shhan(100,300,"프로그램이 너무 큽니다.",15,1,0,0);
	 break;
    case ENOEXEC:shhan(100,300,"실행 파일 오류입니다.",15,1,0,0);
	 break;
    }
  shhan(100,320,"arj 유틸리티를 사용하여 직접 설치하십시요.",15,1,0,0);
  }
else
  {
  shhan(100,300,"설치가 완료되었습니다. 감사합니다.",15,1,0,0);
  shhan(100,320,"예제의 사용방법은 본문을 참고 하십시요.",15,1,0,0);
  }
hom(15,5,625,195,8,15,1);
readpcx16p("won.pcx",20,10);
delay(1000);
getch();
closegraph();
}


typedef struct {
   char manufacturer;   /* pcx 파일 확인 0x0a */
   char version;        /* 버전번호 0x05가 5.0 256컬러 */
   char encoding;       /* 인코딩 방법 0x01-RLL 인코딩 */
   char bpp;            /* 픽셀당 bit수   */
   int xmin,ymin;       /* 그림의 상하좌우 크기 */
   int xmax,ymax;
   int hres;            /* 해상도-전혀 의미가 없음 */
   int vres;
   char palette[48];    /* 팔레트 정보 */
   char reserved;       /* 예약        */
   char colour_planes;  /* 플레인 갯수 HGC=1,VGA=4 */
   int bpl;             /* 줄당 byte 수 */
   int palette_type;
   char filler[58];     /* 예약 영역 */
}PCXHEAD;
/* 점을 찍는 방법으로 16색 pcx를 출력한다.            */
/* 속도가 조금 느리다.                                */
/* filename-출력할 pcx 파일,                          */
/* x,y - 출력할 화면상의 위치                         */
void readpcx16p(char *filename,int x,int y)
{
FILE *fp;
PCXHEAD hd;
unsigned int width,depth;   /* 그림의 폭과 높이 */
unsigned int bytes;         /* 줄당 byte수 */
char palette[768];          /* palette 정보를 담는 배열 */
int i,j;                 /* 임시 변수임 */
fp=fopen(filename,"rb");
if (fp==NULL){     /* 파일 개방에 실패하면 exit() */
    return;
    }
fseek(fp,-769l,SEEK_END);   /* 256 팔렛트 정보 검사 */
 if (fgetc(fp)==0x0c && fread(palette,1,768,fp)== 768)
   {
   printf("not 16 color,but 256 color\n");
   exit(0);
   }
fseek(fp,0l,SEEK_SET);
fread(&hd,1,128,fp);   /* 헤더 읽음 */
if (hd.manufacturer==0x0a && hd.bpp==0x01)
    {
    if (hd.version!=0x03)   /* 팔레트가 있으면 읽음 */
       readpalette16(hd.palette);
    fseek(fp,128,SEEK_SET); /* 헤더 바로 다음 부터 읽음 */
    for (i=0;i<hd.ymax-hd.ymin+1;i++)
       readline16p(fp,hd.bpl,x,y+i);
    }
}
/* 16색 pcx 파일에서 팔렛트정보를 읽어 팔렛트를 setting한다. */
void readpalette16(char *pal_buf)
{
int i;
struct REGPACK reg;
/* 팔레트의 상위 6byte만 사용한다. */
return;
for (i=0;i<48;i++) pal_buf[i]>>=2;
for (i=0;i<16;i++)
    {
    reg.r_ax=0x1000;
    reg.r_bx=i*256+i;
    intr(0x10,&reg);
    }
reg.r_ax=0x1012;
reg.r_bx=0;
reg.r_cx=16;
reg.r_es=FP_SEG(pal_buf);
reg.r_dx=FP_OFF(pal_buf);
intr(0x10,&reg);
}
/* readpcx16p에서 사용하는 서브루틴,한줄을 출력해준다. */
/* fp=출력할 pcx 파일, len= 줄당 byte 수               */
/* x,y - 출력할 화면상의 위치                          */
void readline16p(FILE *fp,int len,int x,int y)
{
int i,j,k,n;     /* 임시 변수들 */
char temp[1040]; /* 임시 버퍼 */
char col[1040];
n=0;
do
{
  i=fgetc(fp);
/* 아래 설명: 압축인 경우 하위 6 bit를 i에 넣고 */
/* 그 다음 byte를 읽어 들여 j에 넣은 후 j를 i번 */
/* 반복해서 버퍼에 집어 넣는다. 압축을 푸는   */
/* 과정이다.                                    */
  if ((i&0xc0)==0xc0)       /* 압축인 경우 */
    {
    i=i&0x3f;
    j=fgetc(fp);
    while(i--) temp[n++]=j;
    }
    else
    { temp[n++]=i; }     /* 압축이 아닌 경우 */
} while (n<len*4);   /* 한꺼번에 4plane을 읽음 */
for (i=0;i<640;i++) col[i]=0;  /* 버퍼를 지움 */
for (i=0;i<4;i++)       /* 플레인 */
  for (j=0;j<len;j++)     /* 수평 바이트 */
    for (k=7;k>=0;k--)     /* 비트        */
      if (temp[j+i*len]&(1<<k)) col[j*8+7-k]|=(1<<i);
for (i=0;i<len*8;i++)      /* col배열에 완성된 그림을 출력한다.*/
  putpixel(x++,y,col[i]);    /* 출력 단위는 한줄이다.            */
}
/* 불쑥 튀어나와 있는 양각을 만든다.                      */
 void dan(int x1,int y1,int x2,int y2,int upcolor,int downcolor,int num,int gap)
 {
 int i,j=0;
 for (i=0;i<num;i++){
 setcolor(upcolor);line(x1-j,y1-j,x1-j,y2+j);line(x1-j,y1-j,x2+j,y1-j);
 setcolor(downcolor);line(x2+j,y2+j,x2+j,y1-j);line(x2+j,y2+j,x1-j,y2+j);
 j+=gap;
 }
 }
/* VGA에서 쑥들어가 있는 한 줄을 만든다.흰색과 바탕보다 진한색을 */
/* 아래위로 사각형만 그려주면 된다.                              */
/* 인수는 DAN과 똑 같지만 gap은 없다.                            */

void hom(int x1,int y1,int x2,int y2,int upcolor,int downcolor,int num)
{
int i;
for (i=0;i<num;i++)
{
setcolor(upcolor);
rectangle(x1+i,y1+i,x2+i,y2+i);
setcolor(downcolor);
rectangle(x1+i+num,y1+i+num,x2+i+num,y2+i+num);
}
}

void bar2(int l,int t,int r,int b)
{
int i;
int incx=(r-l)/20;
int incy=(b-t)/20;
int cx=(r+l)/2;
int cy=(b+t)/2;
for (i=1;i<10;i++)
  {
  bar(cx-incx*i,cy-incy*i,cx+incx*i,cy+incy*i);
  delay(50);
  }
bar(l,t,r,b);
}
